<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //05-02-example02

      //확인문제
      //1. filter 함수의 콜백 함수 부분을 채워서 ①홀수만 추출, ②100 이하의 수만 추출,
      // ③5로 나눈 나머지가 0인 수만 추출해주세요. 그리고 코드의 실행 결과를 적어보세요.

      //변수를 선언합니다.
      let numbers = [273, 25, 75, 52, 103, 32, 57, 24, 76];

      //처리합니다.
      let oddNum = numbers.filter((n) => n % 2 !== 0);
      let twoNum = numbers.filter((n) => n <= 100);
      let divisibleBy5 = numbers.filter((n) => n % 5 === 0);

      //출력합니다.
      console.log(numbers);
      console.log(`${oddNum}\n${twoNum}\n${divisibleBy5}`);

      //2. 이전에 반복문 부분에서 살펴보았던 다음과 같은 코드를 배열의 forEach 메소드를 사용하는 형태로 변경해주세요.

      const array = ["사과", "배", "귤", "바나나"];

      // console.log('# for in 반복문')
      // for (const i in array){
      //   console.log(i)
      // }

      // console.log('# for of 반복문')
      // for (const i of array){
      //   console.log(i)
      // }

      console.log(`# for in 반복문`);
      array.forEach((v, i) => console.log(i));
      console.log(`# for of 반복문`);
      array.forEach((v, i) => console.log(v));

      //정수 n과 k가 주어졌을 때, 1 이상 n 이하의 정수 중에서 k의 배수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요
      //제한사항
      // 1<=n<=1,000,000
      // 1<=k<=min(1,000, n)

      function solution(n, k) {
        let arr = [];
        for (let i = 1; i <= n; i++) {
          if (i % k === 0) {
            arr.push(i);
          }
        }
        return arr;
      }
      console.log(solution(10, 3));
      console.log(solution(15, 5));

      //정수 l과 r이 주어졌을 때, l이상 r이하의 정수 중에서 숫자 "0"과 "5"로만 이루어진 모든 정수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요
      //만약 그러한 정수가 없다면, -1이 담긴 배열을 return합니다.

      function solution03(l, r) {
        let arr = [];
        for (let i = l; i <= r; i++) {
          let str = `${i}`;
          if (str.split("").every((char) => char === "0" || char === "5")) {
            arr.push(i);
          }
        }
        if (arr.length === 0) {
          return [-1];
        }

        return arr;
      }

      console.log(solution03(1, 555));
      console.log(solution03(10, 20));

      //4.
      //정수 배열arr과 2개의 구간이 담긴 배열 intervals가 주어집니다.
      //intervals는 항상 [[a1, b1], [a2, b2]]의 꼴로 주어지며 각 구간은 닫힌 구간입니다. 닫힌 구간은 양 끝값과 그 사이의 값을 모두 포함하는 구간을 의미합니다
      //이때 배열 arr의 첫 번째 구간에 해당하는 배열과 두 번째 구간에 해당하는 배열을 앞뒤로 붙여 새로운 배열을 만들어 return 하는 solution 함수를 완성해 주세요.

      function solution04(arr, intervals) {
        const [start1, end1] = intervals[0];
        const [start2, end2] = intervals[1];
        let result = [];
        for (let i = start1; i <= end1; i++) {
          result.push(arr[i]);
        }
        for (let i = start2; i <= end2; i++) {
          result.push(arr[i]);
        }
        return console.log(result);
      }
      solution04(
        [1, 2, 3, 4, 5],
        [
          [1, 3],
          [0, 4],
        ]
      );

      //현재 느슨한 모드와 엄격 모드의 차이점을 조사해서 간단히 서술하세요.
      //1. 변수를 선언하지 않고 사용하면 에러
      //2. 전역 변수를 생성하지 않는다
      //3. 삭제할 수 없는 프로퍼티를 삭제하려할 때 에러
      //4. 중복 인수명은 구문 에러
      //5. ECMAScript 에서의 엄격모드는 8진 구문을 금지(앞에 0이 붙으면 구문에러)
      //6. 원시값(primitive values)에 프로퍼티를 설정하면 TypeError
      //7. 브라우저에서 엄격 모드의 함수내에서는 더 이상 window객체를 this를 통해 참조할 수 없습니다.

      //5.
      //정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk를 만들려고 합니다
      //변수 i를 만들어 초기값을 0으로 설정한 후 i가 arr의 길이보다 작으면 다음 작업을 반복합니다.
      // - 만약 stk가 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다.
      // - stk에 원소가 있고, stk의 마지막 원소가 arr[i]보다 작으면 arr[i]를 stk의 뒤에 추가하고 i에 1을 더합니다.
      // - stk에 원소가 있는데 stk의 마지막 원소가 arr[i]보다 크거나 같으면 stk의 마지막 원소를 stk에서 제거합니다.

      //위 작업을 마친 후 만들어진 stk를 return 하는 solution함수를 완성해 주세요
      function solution05(arr) {
        stk = [];
        for (let i = 0; i < arr.length; i++) {
          if (stk.length === 0) {
            stk.push(arr[i]);
            i++;
          } else if (stk[stk.length - 1] < arr[i]) {
            stk.push(arr[i]);
            i++;
          } else if (stk[stk.length - 1] >= arr[i]) {
            stk.splice[stk.length];
          }
        }
        return console.log(stk);
      }
      solution05([1, 4, 2, 5, 3]);


      //6.
      //문자열 배열 intStrs와 k,s,l가 주어집니다. intStrs의 원소는 숫자로 이루어져 있습니다.

      //배열 intStrs의 각 원소마다 s번 인덱스에서 시작하는 길이 l짜리 부분 문자열을 잘라내 정수로 변환합니다.이때 변환한 정수값이 k보다 큰 값들을 담은 배열을 return 하는 solution 함수를 완성해 주세요.

      function
    </script>
  </body>
</html>
